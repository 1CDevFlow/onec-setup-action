{"version":3,"file":"366.index.js","mappings":";;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAvHA","sources":[".././node_modules/compare-versions/lib/umd/index.js",".././src/tools/platform83.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.compareVersions = {}));\n})(this, (function (exports) { 'use strict';\n\n    const semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n    const validateAndParse = (version) => {\n        if (typeof version !== 'string') {\n            throw new TypeError('Invalid argument expected string');\n        }\n        const match = version.match(semver);\n        if (!match) {\n            throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n        }\n        match.shift();\n        return match;\n    };\n    const isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\n    const tryParse = (v) => {\n        const n = parseInt(v, 10);\n        return isNaN(n) ? v : n;\n    };\n    const forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n    const compareStrings = (a, b) => {\n        if (isWildcard(a) || isWildcard(b))\n            return 0;\n        const [ap, bp] = forceType(tryParse(a), tryParse(b));\n        if (ap > bp)\n            return 1;\n        if (ap < bp)\n            return -1;\n        return 0;\n    };\n    const compareSegments = (a, b) => {\n        for (let i = 0; i < Math.max(a.length, b.length); i++) {\n            const r = compareStrings(a[i] || '0', b[i] || '0');\n            if (r !== 0)\n                return r;\n        }\n        return 0;\n    };\n\n    /**\n     * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n     * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n     * @param v1 - First version to compare\n     * @param v2 - Second version to compare\n     * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n     */\n    const compareVersions = (v1, v2) => {\n        // validate input and split into segments\n        const n1 = validateAndParse(v1);\n        const n2 = validateAndParse(v2);\n        // pop off the patch\n        const p1 = n1.pop();\n        const p2 = n2.pop();\n        // validate numbers\n        const r = compareSegments(n1, n2);\n        if (r !== 0)\n            return r;\n        // validate pre-release\n        if (p1 && p2) {\n            return compareSegments(p1.split('.'), p2.split('.'));\n        }\n        else if (p1 || p2) {\n            return p1 ? -1 : 1;\n        }\n        return 0;\n    };\n\n    /**\n     * Compare [semver](https://semver.org/) version strings using the specified operator.\n     *\n     * @param v1 First version to compare\n     * @param v2 Second version to compare\n     * @param operator Allowed arithmetic operator to use\n     * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n     *\n     * @example\n     * ```\n     * compare('10.1.8', '10.0.4', '>'); // return true\n     * compare('10.0.1', '10.0.1', '='); // return true\n     * compare('10.1.1', '10.2.2', '<'); // return true\n     * compare('10.1.1', '10.2.2', '<='); // return true\n     * compare('10.1.1', '10.2.2', '>='); // return false\n     * ```\n     */\n    const compare = (v1, v2, operator) => {\n        // validate input operator\n        assertValidOperator(operator);\n        // since result of compareVersions can only be -1 or 0 or 1\n        // a simple map can be used to replace switch\n        const res = compareVersions(v1, v2);\n        return operatorResMap[operator].includes(res);\n    };\n    const operatorResMap = {\n        '>': [1],\n        '>=': [0, 1],\n        '=': [0],\n        '<=': [-1, 0],\n        '<': [-1],\n        '!=': [-1, 1],\n    };\n    const allowedOperators = Object.keys(operatorResMap);\n    const assertValidOperator = (op) => {\n        if (typeof op !== 'string') {\n            throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n        }\n        if (allowedOperators.indexOf(op) === -1) {\n            throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n        }\n    };\n\n    /**\n     * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n     *\n     * @param version Version number to match\n     * @param range Range pattern for version\n     * @returns `true` if the version number is within the range, `false` otherwise.\n     *\n     * @example\n     * ```\n     * satisfies('1.1.0', '^1.0.0'); // return true\n     * satisfies('1.1.0', '~1.0.0'); // return false\n     * ```\n     */\n    const satisfies = (version, range) => {\n        // clean input\n        range = range.replace(/([><=]+)\\s+/g, '$1');\n        // handle multiple comparators\n        if (range.includes('||')) {\n            return range.split('||').some((r) => satisfies(version, r));\n        }\n        else if (range.includes(' - ')) {\n            const [a, b] = range.split(' - ', 2);\n            return satisfies(version, `>=${a} <=${b}`);\n        }\n        else if (range.includes(' ')) {\n            return range\n                .trim()\n                .replace(/\\s{2,}/g, ' ')\n                .split(' ')\n                .every((r) => satisfies(version, r));\n        }\n        // if no range operator then \"=\"\n        const m = range.match(/^([<>=~^]+)/);\n        const op = m ? m[1] : '=';\n        // if gt/lt/eq then operator compare\n        if (op !== '^' && op !== '~')\n            return compare(version, range, op);\n        // else range of either \"~\" or \"^\" is assumed\n        const [v1, v2, v3, , vp] = validateAndParse(version);\n        const [r1, r2, r3, , rp] = validateAndParse(range);\n        const v = [v1, v2, v3];\n        const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];\n        // validate pre-release\n        if (rp) {\n            if (!vp)\n                return false;\n            if (compareSegments(v, r) !== 0)\n                return false;\n            if (compareSegments(vp.split('.'), rp.split('.')) === -1)\n                return false;\n        }\n        // first non-zero number\n        const nonZero = r.findIndex((v) => v !== '0') + 1;\n        // pointer to where segments can be >=\n        const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n        // before pointer must be equal\n        if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)\n            return false;\n        // after pointer must be >=\n        if (compareSegments(v.slice(i), r.slice(i)) === -1)\n            return false;\n        return true;\n    };\n\n    /**\n     * Validate [semver](https://semver.org/) version strings.\n     *\n     * @param version Version number to validate\n     * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n     *\n     * @example\n     * ```\n     * validate('1.0.0-rc.1'); // return true\n     * validate('1.0-rc.1'); // return false\n     * validate('foo'); // return false\n     * ```\n     */\n    const validate = (version) => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n    /**\n     * Validate [semver](https://semver.org/) version strings strictly. Will not accept wildcards and version ranges.\n     *\n     * @param version Version number to validate\n     * @returns `true` if the version number is a valid semver version number `false` otherwise\n     *\n     * @example\n     * ```\n     * validate('1.0.0-rc.1'); // return true\n     * validate('1.0-rc.1'); // return false\n     * validate('foo'); // return false\n     * ```\n     */\n    const validateStrict = (version) => typeof version === 'string' &&\n        /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/.test(version);\n\n    exports.compare = compare;\n    exports.compareVersions = compareVersions;\n    exports.satisfies = satisfies;\n    exports.validate = validate;\n    exports.validateStrict = validateStrict;\n\n}));\n//# sourceMappingURL=index.js.map\n","import { OnecTool } from './onecTool'\nimport * as core from '@actions/core'\nimport { exec } from '@actions/exec'\nimport { downloadRelease } from '../onegetjs'\nimport * as glob from '@actions/glob'\nimport { compareVersions } from 'compare-versions'\nimport { DistributiveType } from 'src/onegetjs/model'\n\nexport class Platform83 extends OnecTool {\n  INSTALLED_CACHE_PRIMARY_KEY = 'onec'\n  version: string\n  cache_: string[]\n  platform: string\n  constructor(version: string, platform: string) {\n    super()\n    this.version = version\n    this.platform = platform\n    this.cache_ = this.getCacheDirs()\n  }\n\n  useNewInstaller(): boolean {\n    return compareVersions(this.version, '8.3.20') >= 0\n  }\n\n  async download(): Promise<void> {\n    let platformType = this.getPlatformType()\n\n    let installerType: DistributiveType = 'full'\n\n    if (platformType == 'linux' && !this.useNewInstaller()) {\n      installerType = 'clientOrServer'\n      platformType = 'deb'\n    }\n\n    await downloadRelease(\n      {\n        project: 'Platform83',\n        version: this.version,\n        osName: platformType,\n        architecture: 'x64',\n        type: installerType\n      },\n      this.getInstallersPath(),\n      true\n    )\n\n    core.info(`onec was downloaded`)\n  }\n\n  async install(): Promise<void> {\n    const installerPattern = this.isWindows()\n      ? 'setup.exe'\n      : this.useNewInstaller()\n        ? 'setup-full'\n        : '*.deb'\n\n    const path = this.getInstallersPath()\n\n    const globber = await glob.create(`${path}/**/${installerPattern}*`)\n    const files = await globber.glob()\n    core.info(`found ${files}`)\n\n    if (this.isLinux() && this.useNewInstaller()) {\n      await exec('sudo', [\n        files[0],\n        '--mode',\n        'unattended',\n        '--enable-components',\n        'server,client_full',\n        '--disable-components',\n        'client_thin,client_thin_fib,ws'\n      ])\n    } else if (this.isLinux()) {\n      for await (const mask of ['common', 'server', 'thin-client', 'client']) {\n        const files = await (\n          await glob.create(`${path}/1c-enterprise83-${mask}_*.deb`)\n        ).glob()\n\n        if (files.length !== 0) {\n          await exec('sudo', ['dpkg', '-i', '--force-all', `${files[0]}`])\n        } else {\n          core.warning(\n            `File not found for ${mask} (mask: 1c-enterprise83-${mask}_*.deb)`\n          )\n        }\n      }\n    } else if (this.isWindows()) {\n      await exec(files[0], [\n        '/l',\n        'ru',\n        '/S',\n        'server=1',\n        'thinclient=1',\n        'RU=1',\n        'EN=1',\n        'LANGUAGES=RU,EN',\n        '/quiet',\n        '/qn',\n        'INSTALLSRVRASSRVC=0',\n        '/norestart'\n      ])\n    } else {\n      core.setFailed(`Unrecognized os ${this.platform}`)\n    }\n  }\n\n  getCacheDirs(): string[] {\n    if (this.isWindows()) {\n      return ['C:/Program Files/1cv8']\n    } else if (this.isLinux() && this.useNewInstaller()) {\n      return ['/opt/1cv8']\n    } else if (this.isLinux()) {\n      return ['/opt/1C/v8.3']\n    } else if (this.isMac()) {\n      return ['/opt/1cv8'] // /Applications/1cv8.localized/8.3.21.1644/ but only .app\n    } else {\n      throw new Error('Not supported on this OS type')\n    }\n  }\n\n  getRunFileNames(): string[] {\n    if (this.isWindows()) {\n      return ['1cv8.exe']\n    } else {\n      return ['1cv8']\n    }\n  }\n}\n"],"names":[],"sourceRoot":""}