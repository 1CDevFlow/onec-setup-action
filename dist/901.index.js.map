{"version":3,"file":"901.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvIA;AAyIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACjJA;AAyDA;AAzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgBA;AA7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAlFA;AAoFA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;ACrHA;AAYA;AAYA;AA/BA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AARA;AACA;AACA;AAMA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAYA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AA2BA;AAhCA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA","sources":[".././src/onegetjs/downloader.ts",".././src/onegetjs/filter.ts",".././src/onegetjs/index.ts",".././src/onegetjs/parse.ts",".././src/onegetjs/request.ts",".././src/tools/onecTool.ts",".././src/unpacker.ts"],"sourcesContent":["import { Response } from 'node-fetch'\nimport * as core from '@actions/core'\nimport { CookieJar } from 'cookiejar'\nimport request from './request'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\nconst RELEASES_URL = 'https://releases.1c.ru'\nconst PROJECTS_URL = '/project/'\nconst LOGIN_URL = 'https://login.1c.ru'\nconst TICKET_URL = `${LOGIN_URL}/rest/public/ticket/get`\n\nexport class Client {\n  login: string\n  password: string\n  cookies: CookieJar\n  ticket = ''\n\n  constructor(login: string, password: string) {\n    if (!login || !password) {\n      const err = new Error('Do not set login or/and password')\n      core.setFailed(err)\n      throw err\n    }\n    this.login = login\n    this.password = password\n    this.cookies = new CookieJar()\n  }\n\n  async auth(): Promise<void> {\n    const continueURL = await this.getAuthToken()\n    await request(continueURL, { cookie: this.cookies })\n  }\n\n  async getAuthToken(url: string = RELEASES_URL): Promise<string> {\n    core.debug('Authorization')\n    const body = {\n      login: this.login,\n      password: this.password,\n      serviceNick: url\n    }\n    const response = await request(TICKET_URL, {\n      method: 'POST',\n      body: JSON.stringify(body),\n      cookie: this.cookies,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    })\n    this.checkResponseError(response)\n    const data = await response.json()\n    return `${LOGIN_URL}/ticket/auth?token=${data.ticket}`\n  }\n\n  async getText(url: string): Promise<string> {\n    const fullURL = new URL(url, RELEASES_URL)\n    const response = await this.get(fullURL.toString())\n    return await response.text()\n  }\n\n  async get(url: string): Promise<Response> {\n    let response = await request(url, { cookie: this.cookies })\n    if (response.status === 401) {\n      core.debug('Re-Authorization')\n      const newURL = await this.getAuthToken(url)\n      core.debug(`Request. [GET] ${newURL}`)\n      response = await request(newURL, { cookie: this.cookies })\n    }\n\n    await this.checkResponseError(response)\n    return response\n  }\n\n  async downloadFile(url: string, output: string): Promise<string | undefined> {\n    const fullURL = new URL(url, RELEASES_URL)\n    const response = await this.get(fullURL.toString())\n    const fileName = extractFileName(response)\n    if (fileName === undefined) {\n      core.error(`Can't extract file name from response for ${url}`)\n      return undefined\n    }\n\n    const fullFileName = path.resolve(output, fileName)\n    try {\n      if (fs.statSync(fullFileName).isFile()) {\n        core.info(`${fileName} already exist`)\n        return fullFileName\n      }\n    } catch {\n      /* empty */\n    }\n\n    core.info(`Downloading ${fileName}...`)\n\n    const destination = fs.createWriteStream(fullFileName, { flags: 'wx' })\n    const contentLength = response.headers.get('content-length')\n    const totalSize = contentLength ? parseInt(contentLength) : 0\n\n    let downloadedSize = 0\n\n    await new Promise((resolve, reject) => {\n      response.body.on('data', chunk => {\n        downloadedSize += chunk.length\n        if (totalSize > 0 && downloadedSize % (1024 * 1024) === 0) {\n          // Каждые MB\n          const progress = Math.round((downloadedSize / totalSize) * 100)\n          core.info(\n            `Download progress: ${progress}% (${Math.round(downloadedSize / 1024 / 1024)}MB / ${Math.round(totalSize / 1024 / 1024)}MB)`\n          )\n        }\n      })\n\n      response.body.pipe(destination)\n      response.body.on('error', reject)\n      destination.on('finish', resolve)\n    })\n\n    // Проверяем размер файла\n    const stats = fs.statSync(fullFileName)\n\n    if (totalSize > 0 && stats.size !== totalSize) {\n      core.warning(\n        `File size mismatch: expected ${totalSize}, got ${stats.size}`\n      )\n      // Удаляем поврежденный файл\n      fs.unlinkSync(fullFileName)\n      throw new Error(`Downloaded file is corrupted: size mismatch`)\n    }\n\n    core.info(`Downloaded (${stats.size} bytes)`)\n    return fullFileName\n  }\n\n  async projectPage(project: string): Promise<string> {\n    return await this.getText(`${PROJECTS_URL}${project}?allUpdates=true`)\n  }\n\n  async checkResponseError(response: Response): Promise<void> {\n    if (response.status === 200) {\n      return\n    }\n    const message = `Response error.\n        Status: ${response.status} (${response.statusText})\n        Body: ${await response.text()}`\n    core.error(message)\n    throw message\n  }\n}\n\nfunction extractFileName(response: Response): string | undefined {\n  const header = response.headers.get('content-disposition')\n  if (header === null) {\n    return undefined\n  }\n\n  const prefix = 'filename='\n  let filename = header.substring(header.indexOf(prefix) + prefix.length)\n\n  if (filename.startsWith('\"') && filename.endsWith('\"')) {\n    filename = filename.substring(1, filename.length - 1)\n  }\n\n  return filename\n}\n","import { ReleaseFile, ArtifactFilter } from './model'\n\nconst x64Pattern = /.*(\\(64-bit\\)|\\(64 бит\\)).*/\nconst rpmPattern = /.+RPM.+(ОС Linux|для Linux$|Linux-систем$).*/\nconst debPattern = /.+DEB.+(ОС Linux|для Linux$|Linux-систем$).*/\nconst linuxPattern = /.*(ОС Linux|для Linux$|Linux-систем$).*/\nconst windowsPattern = /.*(ОС Windows|для Windows$|для Windows\\\\s\\\\+).*/\nconst osxPattern = /.+(OS X|для macOS)$/\nconst clientPattern = /^Клиент.+/\nconst serverPattern = /^[Cервер|Сервер].+/\nconst thinPattern = /^Тонкий клиент.+/\nconst fullPattern = /^Технологическая платформа.+/\nconst offlinePattern = /.+(без интернета|оффлайн).*/\nconst clientOrServerPattern = /^[Клиент|Cервер|Сервер].+/\nconst SHA = /.*(Контрольная сумма|sha).*/\n\ntype Predicate = (value: string) => unknown\n\nexport function getFilters(artifactFilter: ArtifactFilter): Predicate[] {\n  const filters = new Array<Predicate>()\n  filters.push(v => !SHA.test(v))\n\n  switch (artifactFilter.osName) {\n    case 'win':\n      filters.push(windowsPattern.test.bind(windowsPattern))\n      break\n    case 'mac':\n      filters.push(osxPattern.test.bind(osxPattern))\n      break\n    case 'linux':\n      filters.push(linuxPattern.test.bind(linuxPattern))\n      break\n    case 'deb':\n      filters.push(debPattern.test.bind(debPattern))\n      break\n    case 'rpm':\n      filters.push(rpmPattern.test.bind(rpmPattern))\n      break\n  }\n\n  switch (artifactFilter.architecture) {\n    case 'x86':\n      filters.push(v => !x64Pattern.test(v))\n      break\n    case 'x64':\n      filters.push(x64Pattern.test.bind(x64Pattern))\n      break\n  }\n  switch (artifactFilter.type) {\n    case 'full':\n      filters.push(fullPattern.test.bind(fullPattern))\n      break\n    case 'server':\n      filters.push(serverPattern.test.bind(serverPattern))\n      break\n    case 'client':\n      filters.push(clientPattern.test.bind(clientPattern))\n      break\n    case 'thinClient':\n      filters.push(thinPattern.test.bind(thinPattern))\n      break\n    case 'clientOrServer':\n      filters.push(clientOrServerPattern.test.bind(clientOrServerPattern))\n      break\n  }\n\n  if (artifactFilter.offline === true) {\n    filters.push(offlinePattern.test.bind(offlinePattern))\n  } else {\n    filters.push(v => !offlinePattern.test(v))\n  }\n\n  return filters\n}\n\nexport function filter(\n  files: ReleaseFile[],\n  filters: Predicate[]\n): ReleaseFile[] {\n  return files.filter(file => {\n    const failure = filters.find(f => !f(file.name))\n    return failure === undefined\n  })\n}\n","import {\n  ReleaseFile,\n  Version,\n  ReleaseDescription,\n  ArtifactFilter\n} from './model'\nimport { Client } from './downloader'\nimport * as parser from './parse'\nimport * as core from '@actions/core'\nimport * as filter from './filter'\nimport process from 'process'\nimport path from 'path'\nimport * as io from '@actions/io'\nimport { unpackFiles } from '../unpacker'\n\nexport default class OneGet {\n  client: Client\n  downloadTo: string\n\n  constructor(downloadTo: string) {\n    const login = process.env.ONEC_USERNAME ?? ''\n    const password = process.env.ONEC_PASSWORD ?? ''\n    this.client = new Client(login, password)\n    this.downloadTo = downloadTo\n  }\n\n  async auth(): Promise<void> {\n    await this.client.auth()\n  }\n\n  async download(\n    version: Version,\n    artifactFilter: ArtifactFilter\n  ): Promise<string[]> {\n    const filters = filter.getFilters(artifactFilter)\n    const files = filter.filter(version.files, filters)\n\n    if (files.length === 0) {\n      error(`Found't files for version ${JSON.stringify(artifactFilter)}`)\n    }\n\n    core.debug(`Files for downloading ${JSON.stringify(files)}`)\n\n    const downloadedFiles: string[] = []\n\n    for (const file of files) {\n      for (let attempt = 1; attempt <= 2; attempt++) {\n        core.info(`Downloading ${file.name}`)\n\n        core.debug(`Get artifact download page: ${file.name}`)\n        const links = parser.fileDownloadLinks(\n          await this.client.getText(file.url)\n        )\n\n        if (links.length === 0) {\n          core.error(`Don't found links for file ${file.name}`)\n          continue\n        }\n\n        for (const link of links) {\n          const location = await this.client.downloadFile(link, this.downloadTo)\n          if (location !== undefined) {\n            downloadedFiles.push(location)\n            break\n          }\n        }\n        break\n      }\n    }\n\n    return downloadedFiles\n  }\n\n  async versionInfo(project: string, version: string): Promise<Version> {\n    core.debug(`Get project page for: ${project}`)\n    const page = await this.client.projectPage(project)\n    const versions = parser.versions(page)\n    const filteredVersions = versions.filter(v => v.name === version)\n\n    if (filteredVersions.length === 0) {\n      error(`Version ${version} for ${project} not found`)\n    }\n\n    const versionInfo = filteredVersions[0]\n    core.debug(`Version info: ${JSON.stringify(versionInfo)}`)\n\n    versionInfo.files = await this.versionFiles(versionInfo)\n    core.debug(`Version files: ${JSON.stringify(versionInfo.files)}`)\n    return versionInfo\n  }\n\n  async versionFiles(version: Version): Promise<ReleaseFile[]> {\n    core.debug(`Get project version page for: ${version.name}`)\n\n    const page = await this.client.getText(version.url)\n    return parser.releaseFiles(page)\n  }\n}\n\nexport async function downloadRelease(\n  release: ReleaseDescription,\n  destination: string,\n  unpack = false\n): Promise<void> {\n  const downloadDestination = unpack\n    ? path.resolve('tmp', '__downloads__')\n    : destination\n\n  io.mkdirP(downloadDestination)\n  io.mkdirP(destination)\n\n  const oneGet = new OneGet(downloadDestination)\n  await oneGet.auth()\n  const version = await oneGet.versionInfo(release.project, release.version)\n  const artifacts = await oneGet.download(version, release)\n\n  if (unpack) {\n    await unpackFiles(artifacts, destination)\n  }\n}\n\nfunction error(message: string): void {\n  core.error(message)\n  throw message\n}\n","import { parse } from 'node-html-parser'\nimport { ReleaseFile, Version } from './model'\n\nconst PROJECT_VERSIONS_SELECTOR = 'td.versionColumn>a'\nconst RELEASE_FILES_SELECTOR = '.files-container .formLine a'\nconst DOWNLOAD_LINK_SELECTOR = '.downloadDist a'\n\nexport function versions(content: string): Version[] {\n  const root = parse(content)\n  const cells = root.querySelectorAll(PROJECT_VERSIONS_SELECTOR)\n  return cells.map(\n    cell =>\n      ({\n        name: cell.text.trim(),\n        url: cell.getAttribute('href')\n      }) as Version\n  )\n}\n\nexport function releaseFiles(content: string): ReleaseFile[] {\n  const root = parse(content)\n  const cells = root.querySelectorAll(RELEASE_FILES_SELECTOR)\n  return cells.map(\n    cell =>\n      ({\n        name: cell.text.trim(),\n        url: cell.getAttribute('href')\n      }) as ReleaseFile\n  )\n}\n\nexport function fileDownloadLinks(content: string): string[] {\n  const root = parse(content)\n  const cells = root.querySelectorAll(DOWNLOAD_LINK_SELECTOR)\n  return cells\n    .map(a => a.getAttribute('href'))\n    .filter((v): v is string => v !== null && v !== undefined)\n}\n","import fetch, { RequestInit, Response } from 'node-fetch'\nimport { Cookie, CookieJar } from 'cookiejar'\nimport * as core from '@actions/core'\n\nexport interface RequestInit2 extends RequestInit {\n  cookie?: CookieJar\n}\n\nexport default async function request(\n  urlString: string,\n  init?: RequestInit2\n): Promise<Response> {\n  core.debug(`Request [${init?.method ?? 'GET'}] ${urlString}`)\n  const url = new URL(urlString)\n\n  const cookieJar = init?.cookie\n  const cookieValue = cookieJar\n    ?.getCookies({\n      domain: url.host,\n      path: url.pathname,\n      secure: true,\n      script: false\n    })\n    .map(c => c.toValueString())\n    .join('; ')\n\n  const fetchInit = init ?? {}\n  if (cookieValue && fetchInit.headers === undefined) {\n    fetchInit.headers = {\n      cookie: cookieValue\n    }\n  }\n\n  fetchInit.redirect = 'manual'\n  const response = await fetch(urlString, fetchInit)\n  parseCookies(response, cookieJar)\n\n  if (isRedirect(response)) {\n    const locationURL = new URL(\n      response.headers.get('location') ?? '',\n      response.url\n    )\n    core.debug(`Redirect to: ${locationURL}`)\n    return await request(locationURL.toString(), {\n      cookie: cookieJar\n    })\n  }\n\n  return response\n}\n\nfunction isRedirect(response: Response): boolean {\n  return response.status === 301 || response.status === 302\n}\n\nfunction parseCookies(response: Response, cookieJar?: CookieJar): void {\n  if (cookieJar === undefined) {\n    return\n  }\n  response.headers.raw()['set-cookie']?.map(v => {\n    const cookie = new Cookie(v)\n    cookieJar?.setCookie(cookie)\n  })\n}\n","import * as core from '@actions/core'\nimport { OSName } from '../onegetjs/model'\nimport * as cache from '@actions/cache'\nimport * as glob from '@actions/glob'\nimport path from 'path'\nimport { restoreCacheByPrimaryKey } from '../utils'\n\nconst PLATFORM_WIN = 'win32'\nconst PLATFORM_LIN = 'linux'\nconst PLATFORM_MAC = 'darwin'\n\ninterface IOnecTools {\n  CACHE_KEY_PREFIX: string\n  INSTALLED_CACHE_PRIMARY_KEY: string\n  INSTALLER_CACHE_PRIMARY_KEY: string\n  cache_: string[]\n  version: string\n  platform: string\n  getCacheDirs(): string[]\n}\n\nexport abstract class OnecTool implements IOnecTools {\n  CACHE_KEY_PREFIX = 'setup'\n  INSTALLER_CACHE_PRIMARY_KEY = 'installer'\n\n  abstract INSTALLED_CACHE_PRIMARY_KEY: string\n  abstract cache_: string[]\n  abstract version: string\n  abstract platform: string\n  abstract getRunFileNames(): string[]\n  abstract getCacheDirs(): string[]\n  abstract install(): Promise<void>\n  abstract download(): Promise<void>\n  async updatePath(): Promise<void> {\n    for (const element of this.getRunFileNames()) {\n      const pattern = `${this.cache_[0]}/**/${element}`\n      core.info(pattern)\n      const globber = await glob.create(pattern)\n      for await (const file of globber.globGenerator()) {\n        core.info(`add to PATH ${path.dirname(file)} (${file}) `)\n        core.addPath(path.dirname(file))\n        break\n      }\n    }\n  }\n\n  protected getInstallersPath(): string {\n    return `/tmp/${this.INSTALLER_CACHE_PRIMARY_KEY}`\n  }\n\n  protected async handleLoadedCache(): Promise<void> {\n    await this.updatePath()\n  }\n\n  async restoreInstallationPackage(): Promise<string | undefined> {\n    const primaryKey = this.computeInstallerKey()\n\n    const restorePath = this.getInstallersPath()\n    const matchedKey = await restoreCacheByPrimaryKey([restorePath], primaryKey)\n\n    await this.handleLoadedCache()\n    await this.handleMatchResult(matchedKey, primaryKey)\n\n    return matchedKey\n  }\n\n  async restoreInstalledTool(): Promise<string | undefined> {\n    const primaryKey = this.computeInstalledKey()\n\n    const matchedKey = await restoreCacheByPrimaryKey(this.cache_, primaryKey)\n\n    await this.handleLoadedCache()\n    await this.handleMatchResult(matchedKey, primaryKey)\n\n    return matchedKey\n  }\n\n  computeInstalledKey(): string {\n    return `${this.CACHE_KEY_PREFIX}--${this.INSTALLED_CACHE_PRIMARY_KEY}--${this.version}--${this.platform}`\n  }\n\n  computeInstallerKey(): string {\n    return `${this.CACHE_KEY_PREFIX}--${this.INSTALLER_CACHE_PRIMARY_KEY}--${this.INSTALLED_CACHE_PRIMARY_KEY}--${this.version}--${this.platform}`\n  }\n\n  async handleMatchResult(\n    matchedKey: string | undefined,\n    primaryKey: string\n  ): Promise<void> {\n    if (matchedKey) {\n      core.info(`Cache restored from key: ${matchedKey}`)\n    } else {\n      core.info(`${primaryKey} cache is not found`)\n    }\n    core.setOutput('cache-hit', matchedKey === primaryKey)\n  }\n  async saveInstallerCache(): Promise<void> {\n    try {\n      await cache.saveCache(\n        [this.getInstallersPath()],\n        this.computeInstallerKey()\n      )\n    } catch (error) {\n      if (error instanceof Error) core.info(error.message)\n    }\n  }\n\n  async saveInstalledCache(): Promise<void> {\n    try {\n      core.info(`Trying to save: ${this.cache_.slice().toString()}`)\n      await cache.saveCache(this.cache_.slice(), this.computeInstalledKey())\n    } catch (error) {\n      if (error instanceof Error) core.info(error.message)\n    }\n  }\n\n  protected isWindows(): boolean {\n    return PLATFORM_WIN === this.platform\n  }\n\n  protected isMac(): boolean {\n    return PLATFORM_MAC === this.platform\n  }\n\n  protected isLinux(): boolean {\n    return PLATFORM_LIN === this.platform\n  }\n\n  protected getPlatformType(): OSName {\n    switch (this.platform) {\n      case PLATFORM_WIN: {\n        return 'win'\n      }\n      case PLATFORM_MAC: {\n        return 'mac'\n      }\n      case PLATFORM_LIN: {\n        return 'linux'\n      }\n      default: {\n        core.setFailed(`Unrecognized os ${this.platform}`)\n        throw new Error(`Unrecognized os ${this.platform}`)\n      }\n    }\n  }\n}\n","import * as tc from '@actions/tool-cache'\nimport { exec } from '@actions/exec'\nimport * as core from '@actions/core'\nimport * as io from '@actions/io'\n\nexport async function unpack(file: string, destination: string): Promise<void> {\n  core.info(`Unpack ${file} to ${destination}`)\n\n  // Убеждаемся, что директория назначения существует\n  await io.mkdirP(destination)\n\n  if (file.endsWith('.zip')) {\n    await tc.extractZip(file, destination)\n  } else if (file.endsWith('.tar') || file.endsWith('.tar.gz')) {\n    // Используем системный tar для лучшего контроля\n    await exec('tar', [\n      'xz',\n      '--warning=no-unknown-keyword',\n      '--overwrite',\n      '-C',\n      destination,\n      '-f',\n      file\n    ])\n  } else if (file.endsWith('.rar')) {\n    // 7z может завершиться с ошибкой, но частично распаковать файлы\n    await exec('7z', ['x', file, `-o${destination}`, '-y'])\n  } else {\n    throw new Error(`Unsupported archive format: ${file}`)\n  }\n}\n\nexport async function unpackFiles(\n  files: string[],\n  destination: string\n): Promise<void> {\n  for (const file of files) {\n    await unpack(file, destination)\n  }\n}\n"],"names":[],"sourceRoot":""}